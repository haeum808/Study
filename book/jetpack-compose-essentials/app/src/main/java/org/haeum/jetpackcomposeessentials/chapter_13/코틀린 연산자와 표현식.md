## 코틀린의 표현식 구문

가장 기본적인 표현식은 연산자 2개의 피연산자 할당으로 구성된다.

```kotlin
val myresult = 1 + 2
```

## 기본 할당 연산자

본질적으로 할당 연산자는 2개의 피연산자를 이용한다. 왼쪽 피연산자는 값을 할당할 변수이고, 오른쪽 피연산자는 할당할 값이다.

## 코틀린 산술 연산자

값이 양수가 아니라 음수임을 나타내는 단항 음수 연산자가 있다.  
이 연산자는 2개의 피연산자를 이용하는 뺄셈 연산자와 대조된다.

| 연산자  | 설명                   |
|------|----------------------|
| -(단항) | 변수 또는 표현식 값의 부호를 바꾼다 |
| *    | 곱셈                   |
| /    | 나눗셈                  |
| +    | 덧셈                   |
| -    | 뺄셈                   |
| %    | 나머지                  |

## 증강 할당 연산자

```kotlin
x += y
```

위 표현식은 x = x + y와 동일한 작업을 수행하며 프로그래머가 직접 입력할 코드를 줄여준다.

| 연산자  | 설명                     |
|------|------------------------|
| x += y | x와 y를 더한 결과를 x에 할당한다.  |
| x -= y | x에서 y를 뺀 결과를 x에 할당한다.  |
| x *= y | x와 y를 곱한 결과를 x에 할당한다.  |
| x /= y | x를 y로 나눈 결과를 x에 할당한다.  |
| x %= y | x를 y로 나눈 나머지를 x에 할당한다. |

## 증가/감소 연산자

++, -- 연산자를 이용하면 빠르게 수행할 수 있다.

```kotlin
var x = 0
x++ // 변수 x의 값에 1을 더한다.
x-- // 변수 x의 값에서 1을 뺀다.
```

연산자가 변수 이름 앞에 있으면 증가 또는 감소 연산을 다른 연산보다 먼저 수행한다.

## 등치 연산자

| 연산자    | 설명                            |
|--------|-------------------------------|
| x == y | x가 y와 같으면 true를 반환한다.         |
| x > y  | x가 y보다 크면 true를 반환한다.         |
| x >= y | x가 y보다 같거나 그보다 크면 true를 반환한다. |
| x < y  | x가 y보다 작으면 true를 반환한다.        |
| x <= y | x가 y와 같거나 그보다 작으면 true를 반환한다. |
| x != y | x가 y와 같지 않으면 true를 반환한다.      |

## 부울 논리 연산자

주요 연산자는 NOT(!), AND(&&), OR(||)이다.  

NOT(!) 연산자는 부울 변수의 현재 값이나 표현식의 결과를 반전시킨다.  
OR(||) 연산자는 2개의 피연산자 중 하나가 true로 평가되면 true를 반환하고, 그렇지 않으면 false를 반환한다.  
AND(&&) 연산자는 2개의 피연산자 모두가 true일 때만 true를 반환한다.

## 범위 연산자

범위 연산자 구문은 다음과 같다.

```kotlin
x..y
```

이 연산자는 x에서 시작해 y에서 끝나는 숫자 범위를 나타낸다. x와 y는 모두 범위 내에 포함된다.

## 비트와이즈 연산자

### 비트와이즈 반전

비트와이즈 반전은 inv() 연산을 이용해 수행하며, 숫자의 모든 비트를 반전한다.

```
00000011 NOT
========
11111100
```

### 비트와이즈 AND

비트와이즈 AND는 and() 연산을 이용해 수행한다.  
두 숫자를 비트 단위로 비교하고, 각 숫자에서 두 비트가 모두 1인 위치의 비트값을 1로 한 결과를 반환한다.  
비트 위치 중 하나라도 0이 있으면 해당 위치의 값은 0이 된다.

```
10101011 AND
00000011
========
00000011
```

### 비트와이즈 OR

비트와이즈 OR도 숫자의 이진수 시퀀스를 비트 단위로 비교한다.  
비트와이즈 AND 연산과 달리 비트와이즈 OR은 첫 번째 또는 두 번째 피연산자 중 1이 하나라도 있으면 해당 위칫값을 1로 한다.

```
10101011 OR
00000011
========
10101011
```

### 비트와이즈 XOR

비트와이즈 XOR은 xor() 연산을 이용해 수행한다. 비트와이즈 OR과 비슷하다.  
각 비트 위치 중 하나만 1일 때 결괏값의 해당 비트 위치가 1이 된다. 두 비트의 위치가 모두 1 또는 0이면 결과의 해당 비트가 0이 된다.

```
10101011 XOR
00000011
========
10101000
```

### 비트와이즈 왼쪽 시프트

비트와이즈 왼쪽 시프트는 이진수의 각 비트를 저장한 위치만큼 왼쪽 방향으로 이동한다.  
정수를 왼쪽으로 한 비트만큼 이동하면 값이 두 배가 되는 효과가 있다.  
비트를 왼쪽으로 이동시키면서 비게 되는 가장 오른쪽 위치에는 0을 배치한다.  
또한 가장 왼쪽 비트가 해당 값을 저장하는 변수 크기 이상으로 이동하면 해당 비트를 삭제한다.

```
10101011 Left Shift one bit
========
101010110
```

코틀린에서 비트와이즈 왼쪽 시프트 연산자는 shl() 연산을 이용하며, 시프트할 비트 수를 전달한다.

### 비트와이즈 오른쪽 시프트

비트와이즈 오른쪽 시프트는 여러분이 예상한 대로 오른쪽으로 시프트한다는 점을 제외하고는 비트와이즈 왼쪽 시프트와 동일하다.  
정수를 오른쪽으로 한 비트 이동하는 것은 값을 절반으로 나누는 것과 같다.  
비트를 오른쪽으로 이동하므로 결과를 저장하는 데이터 타입에 관계없이 최하위 비트를 유지할 수 없게 되며, 결과적으로 최하위 비트는 삭제된다.  
이동에 따라 자리가 비는 상위 비트는 양수, 음수를 나타내는 부호 비트 설정 여부에 따라 0또는 1로 채운다.

```
10101011 Right Shift one bit
========
01010101
```

비트와이즈 오른쪽 시프트는 shr() 연산을 이용해 수행하며, 이동할 비트 수를 전달한다.
