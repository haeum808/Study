## 프로그램도 실패를 한다

프로그램도 실패를 한다. 예를 들어, 파일에 무엇을 기록하려고 할 때 하드 디스크가 이미 꽉 차 있는 경우 기록에 실패한다.  
파일에 기록하려고 했는데 실패한 경우에 어떤 경우도 없다면 사용자는 실패를 알아차리기 힘들다.  
대참사가 일어나기 전에 발견할 수 있도록, 프로그래밍 언어에도 가스 누출 검지기 같은 '실패를 알리는 구조'가 필요하다.

## 실패를 어떻게 전달할까?

shippai라는 함수는 성공할 수도 실패할 수도 있다.  
어떻게 '성공했을 때의 처리'와 '실패했을 때의 처리(에러 처리)'를 만들면 될까?  

하나는 shippai 함수가 반환값으로 실패를 전달하면 호출처가 반환값을 체크해서 에러 처리를 하는 방법이다.  
다른 하나는 shippai 함수를 호출하기 전에 에러 처리 코드를 등록해두고, 실패 시 에러 처리 코드로 점프하는 방법이다.

### 반환값으로 실패를 전달한다

예를 들어 shippai 함수가 반환하는 값을 '성공했을 때 0을 반환, 실패했을 때 그 이외의 값을 반환한다'고 정해두는 방법이다.  
호출처는 shippai 함수를 호출해서 그 반환값을 체크한다.

```C
// C 언어
if(shippai()){
  /* 에러 처리 */
}
```

그러나 2가지 문제점이 있다.
- 실패를 놓친다.
- 에러 처리 때문에 코드를 해석하기 어렵다.

#### 실패를 놓친다

프로그래머가 반환값 확인을 잊어버렸을 때 실패를 놓치게 된다.  
그러면 shippai 함수를 사용한 후 반환값을 체크하지 않고 '처리는 성공했다'고 생각해버리는 코드를 쓰게 된다.  
이런 경우에는 코드를 쓴 타이밍과 문제를 발견하는 타이밍이 어긋나기 때문에, 코드의 문제점을 찾기 위해 많은 고생을 하기 십상이다.  
shippai 함수와 관계가 없어 보이는 곳에서 문제를 발견할 수도 있다.

#### 에러 처리 때문에 코드를 해석하기 어렵다

예를 들어 실패 가능성이 있는 처리 3개를 실행하고 만약 어딘가에서 실패가 발생하면 그 이후 처리를 하지 않고 에러 처리를 한다고 하자.  
3개의 처리를 각각 shippai("A"), shippai("B"), shippai("C")라고 하자.

```
// C 언어
int main() {
  if(!shippai("A"){
    // 실패했을 때의 처리
  }else if(!shippai("B")){
    // 실패했을 때의 처리
  }else if(!shippai("C")){
    // 실패했을 때의 처리    
  }
}
```

좀 더 읽기 쉽도록 할 방법은 없을까? 이 에러 처리가 동일한 처리라면 한 곳에 정리해두고 싶다. 어떻게 하면 될까?

#### 점프로 에러 처리를 정리한다

에러 처리를 정리하기 위해 예외를 사용할 수 있지만, C 언어에는 예외 기능이 없다. 그래서 goto를 사용한다.

```
// C 언어
int main() {
  if(!shippai("A")) goto ERROR;
  if(!shippai("B")) goto ERROR;
  if(!shippai("C")) goto ERROR;
  return;
ERROR:
  // 실패했을 때의 처리
}
```

실패했을 때의 처리는 ERROR로 점프했을 때만 실행된다.  
코드 상에서는 실패했을 때의 처리가 원래 하고 싶은 것을 기술한 코드와 분리되어 있다.

### 실패하면 점프한다

C 언어가 나오기 한참 전부터 다른 방법의 에러 처리가 존재했다.  
그것은 '에러가 발생했을 때 점프할 장소를 사전에 등록해두는' 방법이다.  
이 방법이 발전해서 현재의 '예외 처리'가 된 것이다.

#### UNIVAC I의 경우

'에러가 발생했을 때 점프한다'는 발상은 프로그래밍 언어보다 먼저 존재했다.  
컴퓨터 UNIVAC I에는 '계산 시 오버플로우가 발생하면 000번지에 있는 명령을 실행한다'는 기능이 있었다.  
이런 기능을 '인터럽트'라고 불렀으며, 현재에도 에러 처리뿐만 아니라 다양한 목적으로 사용되고 있다.

#### COBOL의 경우

COBOL에는 2 가지 에러 처리가 준비되어 있었다.  
현대의 예외 처리가 범용적 구문인 것과 달리, 이 2 가지 에러 처리를 위해 각각의 별도 구문이 사용되었다.

```
// COBOL
READ <파일명> AT END <에러 시 처리>
ADD <함수명> ON SIZE ERROR <에러 시 처리>
```

#### PL/I의 경우

PL/I는 유연하고 통일된 에러 처리를 위해서 'ON 구문'을 도입했다.  

```
// PL/I
SHORI: procedure;
  on error go to ERROR; // 에러가 발생하면 ERROR로 점프해라는 의미
  call shippai(1);
  call shippai(2);
  call shippai(3);
  return;
  ERROR: < 에러 시 처리 >;
end;
```

C 언어 코드에서는 if 문으로 반환값을 체크하고 있지만, 여기서는 체크가 없어졌다.  
사람이 반환값 체크 코드를 잊어버리지 않도록 코드를 쓰지 않고 언어 처리계가 실패를 체크하고 있기 때문이다.  

PL/I에서는 새로운 실패 종류가 추가되었다.  
그리고 실패 종류에 따라 에러 처리 내용을 변경하는 것도 간단해졌다.  

한 가지 더 중요한 기능으로 새롭게 정의한 실패를 프로그래머가 발생시킬 수 있었다.  
PL/I에서는 예를 들어 signal condition (MY_ERROR)라고 쓰면 MY_ERROR를 발생시켜서 실패를 알리는 형식이다.

## 실패할 것 같은 처리를 묶는 구문

Java 등의 구문에서는 '실패할 것 같은 코드를 미리 try{...}로 묶어둔 후 실패했을 때 처리를 쓰는' 형식이다.  
이 구문은 언제, 왜 만들어진 것일까?

### John Good enough의 주장

"프로그래머는 '명령이 예외를 던질 가능성이 있다는 것을 잊어버리고 최적이 아닌 장소 또는 최적이 아닌 종류의 예외 처리를 사용하는 등의 실수를 할 가능성이 있다."  
여기서 제안된 '묶는 구문'이 현재 대부분의 언어가 채용하고 있는 '실패할 것 같은 처리를 묶은 후 에러 처리를 나중에 기술'하는 구문의 시초가 되었다.  
그리고 '어떤 예외를 던질지 명시적으로 선언한다'는 설계 방침은 Java의 검사 예외로 계승되었다.

### CLU에 도입

프로그래밍 언어 CLU는 예외 처리 메커니즘을 도입했다.  
그때 추가된 것이 명령 뒤에 에러 처리를 쓰는 except 구문이었다.

```
// CLU
begin
  % 실패할 것 같은 처리
end except when 실패 종류:
  % 실패할 것 같은 처리
end
```

### C++에 도입

C++은 실패할 것 같은 처리의 앞 부분에 try를, 발생한 실패를 캐치하는 처리 블록 앞에 catch라는 키워드를 사용하는 구문을 추가했다.

```
// C++
try {
  // 실패할 것 같은 코드
} catch {
  // 에러 처리 명령
}
```

또한 예외를 발생시키기 위한 명령으로 throw라는 용어가 만들어졌다.

### Windows NT 3.1에 도입

Microsoft사는 구조화 예외를 도입했다.  
구조화 예외에는 __try와 __expect 그리고 __finally라는 키워드가 있었다. __finally란 무엇일까?

```
// C언어
__try{

  __try{
    // 실패할 것 같은 코드
  }__finally{
    // 실패해도 성공해도 실행하고 싶은 코드
  }
}__except(...){
  // 에러 처리 코드
}
```

## 출구는 하나다

### 왜 finally를 도입한 것일까?

Microsoft의 대답은 다음과 같다.  
"구조화 예외 처리를 채욤함으로 코드의 신뢰성을 높일 수 있었다.  
예를 들어, 프로그래머가 예측하지 못한 종료가 발생했을 시 메모리 블록이나 파일 등의 리소스를 잘 닫을 수 있게 된다.  
또한 메모리 부족 등의 특정 문제에 대해서도 goto 구문이나 반환값 개념을 사용하지 않고 간단한 구조화 코드로 대응할 수 있다."

### 짝이 되는 처리를 반드시 실행한다

메모리를 확보 후 나중에 개방한다거나, 파일을 열었다가 닫는 처리, 락을 걸었다가 푸는 처리 등이다.  
짝이 되는 처리를 한 쪽 실행했다면, 다른 한쪽도 반드시 실행하는 것이 좋다.

```
// C 언어
lock(m);
// 락이 필요한 처리
if(...){
  unlock(m); // 출구 앞에서 락을 해제
  return;
}
// 락이 필요한 처리
unlock(m); // 출구 앞에서 락을 해제
return;
```

이 문제를 해결하는 방법에는 3 가지가 있다.

#### finally를 사용해서 해결

try 블록 안에서 예외가 발생하든지 발생하지 않든지, finally 블록은 반드시 실행된다.

```
// Java
try{
  // 실패할지도 모르는 코드
} catch(...) {
  // 예외 처리 코드
} finally {
  // 반드시 실행되는 코드
}

// Ruby
begin
  // 실패할지도 모르는 코드
rescue
  // 예외 처리 코드
ensure
  // 반드시 실행되는 코드
end

// Python
try:
  // 실패할지도 모르는 코드
except:
  // 예외 처리 코드
finally:
  // 반드시 실행되는 코드
```

#### Finally가 없는 C++에서의 해결

C++은 fianlly를 가지고 있지 않다.  
C++에서는 RAII라는 기술을 사용하는 것이 일반적이었다.  
예를 들어 파일 같이 '열었다가 닫아야'하는 대상을 다루기 위해 그 대상만을 위한 클래스를 만들어서 해당 클래스의 생성자에서 열어소 소멸자에서 닫는다.

```
// C++
class SampleRAII {
  public:
    // 생성자
    SampleRAII()
      : resource(lock()) {
    }
    
    // 소멸자
    ~SampleRAII() {
      unlock();
    } 
...
}
```

#### D언어의 scope(exit)를 사용한 해결

'열었다가 닫는다'와 같이 긴밀하게 연계되어 있는 처리는 코드 상에서도 가까운 위치에 정리해두는 것이 알기 쉽다.  
이런 생각을 바탕으로 D 언어는 스코프라는 개념을 도입했다.  
스코프 가드를 사용하면 스코프를 벗어날 때 할 처리를 미리 등록해둘 수 있다.

```
// D 언어
void abc()
{
  Mutex m = new Mutex;
  
  lock(m); // mutex를 락한다.
  scope(exit) unlock(m); // 스코프 종료 시에 락을 풀어주라고 등록함.
  
  foo(); // 처리를 실행
}
```

## 어떤 경우에 예외를 던질까?

에러가 발생하면 그것을 알리는 방법은 '반환값을 사용해서 반환한다'와 '예외를 던진다' 2가지가 있었다.  
그럼 어떤 경우에 반환값을 사용하고, 어떤 경우에 예외를 사용하면 되는 것일까?

### 함수 호출 시 인수가 부족한 경우

예를 들어 인수 두 개를 가진 함수가 인수 한 개만 호출한 경우 어떤 일이 벌어질까?  
Python과 Ruby는 함수 호출 시점에서 예외를 던진다.  
그러나 JavaScript는 인수에 '미정의를 의미하는 특수한 값'을 사용해서 처리를 계속한다.

```
// Python
def foo(x, y):
  print x, y
  
foo(1)

// 결과 (예외)
Traceback (most recent call last):
  File "tmp.py", line 4, in <module>
    foo(1)
TypeError: foo() takes exactly 2 arguments (1 given)

// Ruby
def foo(x, y)
  p x, y
end

foo 1

// 결과 (예외)
tmp.rb:1:in `foo': wrong number of arguments (1 for 2)
(ArgumentError)
        from tmp.rb:5:in `<main>'

// JavaScript
function foo(x, y){
  console.log(x, y);
}

foo(1)

// 결과 (성공)
1 undefined
```

### 배열 범위 밖에 있는 것을 취득하려고 했을 때

배열 범위 밖에 있는 것에 접근하려는 것이다.  
Python은 예외를 던진다. 그러나 Ruby에서는 '없는 것을 의미하는 특수한 값' nil을 반환한다.  
JavaScript에서는 undefined를 반환한다.

```
// Python
x = [0, 1, 2]
print x[3]

// 결과 (예외)
Traceback (most recent call last):
  File "tmp.py", line 2, in <module>
    print x[3]
IndexError: list index out of range

// Ruby
x = [0, 1, 2]
p x[3]

// 결과 (성공)
nil

// JavaScript
x = [0, 1, 2];
console.log(x[3]);

// 결과 (성공)
undefined
```

이 3 가지 언어의 설계자는 모두 고도의 기술력을 가진 프로그래머이지만, 어떤 경우에 예외를 던질지에 대해선 의견이 일치하지 않는다.  
예외는 어떤 경우에 사용해야만 하는가, '예왹적 상황'이란 무엇인지에 대한 정답은 없다.

### 틀리면 바로 예외를 던진다

작은 규모의 프로그램의 경우에는 Python과 같이 바로 예외를 던지는 쪽이 JavaScript 같이 undefined 처리하는 것보다 좋다.  
코드의 품질을 높이기 위해서는 버그가 존재하는 것을 빨리 알아채고 수정하는 수밖에 없다.  
즉, 무언가가 이상하다면 빨리 문제를 발견하는 것이 중요하다.  

예외의 이점은 '실패를 놓치지 않는 것'이다.  
이런 '이상하면 처리를 정지하고 빨리 보고해야 한다'는 설계 이념을 'fail first'라고 부른다.

## 예외의 전파

Java를 포함해서 대부분의 예외 처리에서는 예외가 호출처로 전파된다.  
어떤 함수에서도 처리가 되지 않으면 프로그램은 비정상 종료된다.

### 예외 전파의 문제점

어떤 함수 f의 소스 코드를 살펴봐도, 함수 f가 어떤 예외를 던질 가능성이 있는지 모른다.  
함수 f가 호출하고 있는 다른 함수 g 안에서 예외가 발생해서 그것이 전파되어 오는 경우도 있다.  
즉, 함수 f가 호출하는 모든 함수의 소스 코드를 보지 않으면 함수 f가 어떤 예외를 던질 가능성이 있는지 알 수 없다.

### Java의 검사 예외

Java에서는 'throw에서 던질 수 있는 것', 즉 다른 수많은 언어들이 '예외'라고 부르고 있는 것을 다음과 같이 더 세분화하고 있다.  
'예외 처리를 하지 않아도 되는 중요한 문제'와 '예외 처리를 해도 좋은 실행 시 예외' 그리고 '예외 처리를 해도 좋은 기타 예외'가 그 3 가지다.  
그리고 이 이 '기타 예외'는 검사 예외라고도 불리며, 만약 메소드 밖으로 던지는 것이면 그것을 메소드 정의 시에 선언해줄 필요가 있다.  
그것을 위해 준비되어 있는 것이 throw 절이다.

```java
// Java
class Foo {
    // Shippai는 MyException 을 던진다.
    void shippai() throws MyException {
        throw new MyException();
    }
    
    // shippai를 사용하기 위해서는 (방법 1) 'throws MyException'이라 선언하던가,
    void foo() throws MyException{
        shippai();
    }
    
    // (방법 2) MyException을 catch 해서 에러 처리한다.
    void bar() {
        try{
            shippai();
        }catch (MyException e) {
            //...
        }
    }
}

class MyException extends Exception {}
```

검사 예외를 사용하면 '깜박하고 예외를 던질 가능성을 놓쳐버리는 일' 따위는 발생하지 않게 된다.  
동작하지 않는 경우는 놓친 것을 컴파일러가 지적해준다.

### 검사 예외가 잘 사용되지 않는 이유

다른 언어에서는 잘 채용되고 있지 않다. 왜 그런 걸까?  
한 마디로 말하면, 귀찮기 때문이다.  
throws나 try/catch에 기술하는 예외의 개수가 너무 방대해 지거나, 어떤 메소드에서 던질 예외를 하나 추가하면 그 메소드를 호출하고 있는 모든 메소드를 수정해야만 한다.

## 정리

실패를 전달하는 방법 2 가지에는 어느쪽에도 장단점이 있어서 각각의 장단점을 잘 파악한 후 적재적소에 사용하는 것이 중요하다.
